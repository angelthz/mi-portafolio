---
title: '1. React'
pubDate: 2025-04-03
description: 'Aplicacion para generar y sincronizar las letras de archivos de audio "mp3"'
author: '@angelthz'
tags: ["typescript", "html", "css"]
slug : 'curso-react'
category: 'javascript'
---

# 1. Sintaxis JSX

La sintaxis JSX es una sintaxis propia de React JS similar a HTML, que nos permite declarar los componentes dentro de codigo Javascript. 


---
# 2. Componentes

## 2.1 Que es un componente?

## 2.1 Definicion

>Definición: **Un componente de React es una función de JavaScript a la que puedes _agregar marcado_**.


Ejemplo de un componente:

![[Pasted image 20241105205536.png]]


**Ejemplo**
Declaración de un componente funcional
```jsx
export default Profile(){
	return (
		<img src="image.jpg" alt="Una imagen">
	)
}
```

Llamado a un componente

```jsx
function App() {
  let estaciones = ["Primavera","Verano","Otoño","Invierno"];
  return (
	  <>
		  <Profile></Profile>
	  </>
  )
}
export default App
```


# 2.2 Componentes de Clase

Un componente de clase no es mas que una Clase que nos permite definir la estructura de nuestros de un componente mediante React. La sintaxis de clases era la forma mas utilizada y recomendada por React para definir componentes, sin embargo esto cambio y a partir de la versión 18> esta se ha dejado a un lado para usar la declaración de componentes funcionales. 

Es importante conocer la sintaxis de Componentes de Clase para entender aquellos proyectos basados en este tipo de declaracion o bien aquellos proyectos que utilizan versiones de React menores a la 18.0.


**Componente de clase**

Estructura básica de un componente de clase.

```jsx
import React, {Component} from 'react'

export default class MyComponente extends React{
	constructor(props){
		super(props);
		this.state = {
			//values
		}
	}
	//metodos heredadados de Component
	componentDidMount(){
	
	}
	
	componentDidUpdate(prevProps, prevState){
	
	}
	
	componentWillUnmount(){
	
	}
	render(){
	
	}
	//metodos propios
}
```

## 2.2 Construir un componente de clase


Para construir un componte de clase hacemos uso de la sintaxis de clases de Javascrip, pero debemos tener en cuenta que estas deben contar con las siguientes caracteristicas:

+ Heredar de Component.
+ Es obligatorio declarar el metodo **_render()_**, que como su nombre lo dice es el encargado de renderizar en el navegador los elementos declarados mediante la sintaxis JSX.
+ Se recomienda que declarar un componente en archivo ".jsx" por separado.

**Ejemplo**

**Paso 0:** Realizar los import.

Aunque este paso se puede omitir en versiones mas actuales de React, como buena practica de programación se recomienda hacerlo.

```jsx
import React, {Component} from "react";
```

**Paso 1:** Declarar una clase
Creamos una clase con el nombre de nuestro componente y que herede de **Component** (extends Component).

```jsx
import React, {Component} from "react";
class Profile extends Component{

}
```

**Paso 2:** Agregar el método render y el marcado.
Esta clase deberá tener el declarado el metodo **render()**, este método deberá retornarnos nuestro componente para eso deberemos retornar y especificar la construcción del componente en si, con la sintaxis JSX.

```jsx
import React, {Component} from "react";
class Profile extends Component{
	render(){(
		<div>
			<img src="imagen.jpg" alt="Kath Jhonson">
		</div>	
	)}
}
```

>Nota: al igual que con los componentes funcionales, si estos ocupan mas de una linea debemos de encerrar en paréntesis todo el marcado JSX.

**Paso 3:** Exportar el componente.

Podemos exportar nuestro componente en la misma declaracion de la clase o debajo de la definicion de nuestra clase.

```jsx
import React, {Component} from "react";
export default class Profile extends Component{
	render(){(
		<div>
			<img src="imagen.jpg" alt="Kath Jhonson">
		</div>	
	)}
}
```
O bien:
```jsx
import React, {Component} from "react";
class Profile extends Component{
	render(){(
		<div>
			<img src="imagen.jpg" alt="Kath Jhonson">
		</div>	
	)}
}
export default Profile;
```


## 2.3 Propiedades

Las **_props_** son un objeto que reciben los componentes de clase mediante su constructor, dicho objeto (props) esta conformado mediante los atributos y valores que le son asignados al componente al momento de su llamada o declaración. 

Y pueden ser utilizados en todo momento por la clase del Componente.

### Llamando a un Componente

Para llamar a un componente simplemente realizamos el _import_ correspondiente y usamos la sintaxis Jsx para declararlo.

```jsx
import ProfileCard from './ProfileCard.jsx'
function App(){
	return(
		<div>
			<ProfileCard></ProfileCard>
		</div>
	)
}
```

### Enviando props

Si queremos pasarle propiedades (valores) a nuestro componente usamos una sintaxis muy parecida a la de los atributos en _html_ (atributo-valor).

**html**

```html
<img src="imagen.jpg" alt="Hello Worl">
```

**React jsx**

``` jsx
import ProfileCard from './ProfileCard.jsx'
function App(){
	return(
		<div>
			<ProfileCard desc="Foto de una famosa cientifica"></ProfileCard>
		</div>
	)
}
```

### Utilizando props

Para usar los valores enviados como _props_ al llamar a nuestro componente, debemos inicializar el constructor de nuestra clase con un
parámetro llamado **_props_**. Y enviarlo al constructo padre (super).


```jsx
import React, {Component} from "react";
export default class Profile extends Component{
	//El constructor recibe las props
	constructor(props){
		super(props)
	}
	render(){(
		<figure>
			<img src="imagen.jpg" alt="Kath Jhonson">
			<figcaption></figcaption>
		</figure>	
	)}
}
```

Al momento de instanciar el componente se inicializa con todos los valores enviados como **_props_**, y la clase puede hacer uso de ellos.

Para acceder a los valores accedemos al valor mediante la notación del punto (objeto.propiedad).

```jsx
import React, {Component} from "react";
export default class Profile extends Component{
	//El constructor recibe las props
	constructor(props){
		super(props)
	}
	render(){(
		<figure>
			<img src="imagen.jpg" alt="Kath Jhonson">
			{/*usando las props*/}
			<figcaption>{props.desc}</figcaption>
		</figure>	
	)}
}
```

### Tipos de datos para las props

Las propiedades pueden ser valores (primitivos o no primitivos referenciales), esto incluye:
+ Numbers
+ Strings
+ Booleans
+ Arrays
+ Objects
+ Functions
+ React Elements
+ React Components

### Pasando otros tipos de datos

Como mencionamos podemos enviar como **_props_** diferentes tipos de datos, para esto debemos tener en cuenta lo siguiente:

>Nota: Para tipos de datos que no sean Strings, es necesario usar la sintaxis jsx mediante el uso de bloques {}.

Si no lo hacemos de esta manera y solo usamos comillas siempre estaremos enviando _strings_.

>Nota: Es posible enviar múltiples props en la misma declaración o llamado de nuestro componente :).

**Strings**

Usamos las comillas

```jsx
<div>
	<ProfileCard desc="Foto de un famoso"></ProfileCard>
</div>
```

**Numbers**

```jsx
<div>
	<ProfileCard 
		desc="Foto de un famoso"
		age={29}
	>
	</ProfileCard>
</div>
```

**Booleans**

```jsx
<div>
	<ProfileCard 
		desc="Foto de un famoso"
		age={29}
		isTrue={true}
	>
	</ProfileCard>
</div>
```

**Arrays**

```jsx
<div>
	<ProfileCard 
		desc = "Foto de un famoso"
		age = {29}
		isTrue = {true}
		arreglo = {[1,2,3,4,5]}
	>
	</ProfileCard>
</div>
```

**Objetos**

```jsx
<div>
	<ProfileCard 
		desc = "Foto de un famoso"
		age = {29}
		isTrue = {true}
		arreglo = {[1,2,3,4,5]}
		unObjeto = {
			cat = {
				color : orange,
				edad : 2
			}
		}
	>
	</ProfileCard>
</div>
```

El acceso a estos es igual, accedemos al valor mediante el nombre establecido en cada prop.

## 2.4 State

El _state_ de un componente de _react_, es el conjunto de variables del componente que intervienen para cambiar, modificar o volver a renderizar al componente en un momento dado.

Siendo mas técnico en un componente de clase, el _state_ es un atributo de nuestros componentes de clase que específicamente va a ser objeto literal de Js, el cual se va encargar de almacenar aquellas variables y su valor que van a ser requeridos para modificar el estado del componente.

```jsx
//ejemplo de declaraciond del state
this.state = { }
```

**Características**

1. El _state_ es inmutable.
2. No se puede modificar directamente.
3. Es asincrono.
4. Para hacer cambios usamos el metodo setState()
5. El flujo es unidireccional del Padre al Hijo.
6. Un cambio en el _state_ provoca un re-renderizado del componente.

En un componente de clase, el _state_ esta siempre va estar definido e inicializado en el constructor.

**Ejemplo contador**

**1.Declarando nuestro state**

Para definir una variable que formara parte del _state_ de nuestro componente, inicializamos el atributo _state_ de nuestro componente añadiéndole un objeto con el valor/es que formaran parte del _state_.

La propiedad _state_ es un objeto el cual almacenara todos los valores que formaran parte del _state_.

```jsx
import React, {Component} from "react";

export default class Contador extends Component{
	constructor(){
		//añadimos la prop contador al objeto state
		this.state = {
			contador : 0
		}
	}
	//...
}
```

**2. Modificando el state**

Como mencionamos el estado no puede ser modificado directamente para cambiarlo debemos hacer uso del metodo this.setState().

En nuestro ejemplo de contador vamos agregar dos metodos (sumar y restar) para modificar el valor de _state_ contador.

```jsx
import React, {Component} from "react";

export default class Contador extends Component{
	constructor(){
		this.state = {
			contador : 0
		}
	}
	//metodos adicionales
	sumar = ()=> {
		//llamando a setState()
		this.setState({
			contador : this.state.contador + 1
		})
	}
	restar = ()=> {
		//llamando a setState()
		this.setState({
			contador : this.state.contador + 1
		})
	}
}
```

Nota como en los metodos sumar y restar llamamos al metodo `this.setState()` para modifcar el _state_, tambien nota como es que al asignar el nuevo valor de contador primero obtenemos el valor actual de contador y le sumamos/restamos 1.

**3. Añadiendo funcionalidad**

Para ver el resultado y modificar el _state_ vamos a agregar en el metodo _render()_ de nuestro componente un marcado JSX. Que se compondra de lo siguiente:

- h2 : Para mostrar el titulo de nuestro componente.
- h3 : Para mostrar el valor del state.
- button : Para añadir la funcionalidad a los botones y mediantes estos invocar a los metodos sumar y restar.

```jsx
import React, {Component} from "react";

export default class Contador extends Component{
	constructor(){
		this.state = {
			contador : 0
		}
	}
	sumar = ()=> {
		this.setState({
			contador : this.state.contador + 1
		})
	}
	restar = ()=> {
		this.setState({
			contador : this.state.contador - 1
		})
	}

	render(){
		return(
			<div>
				<h2>Ejemplo state</h2>
				<h3>{this.state.contador}</h3>
				<button onClick={this.sumar}>+</button>
				<button onClick={this.restar}>-</button>
			</div>
		)
	}
}
```

Al momento de que se renderizen los elementos de nuestro componente los botones invocaran sus metodos correspondientes y haran el llamado a setState() actualizando el _state_ y volviendo a re-renderizar el componente.

## 2.5 Manejo de eventos

Para el manejo de eventos, React nos ofrece propiedades que nos facilitan la asignación de eventos a los elementos mediante la sintaxis JSX.

De hecho es muy similar a como lo hacemos con un elemento html nativo, en html tendríamos lo siguiente al momento de asignar un evento a un elemento.

**_html_**

```html
<button onclick="jsHandlerFunction"></button>
```

Mientras que con React hariamos lo siguiente:

**_React**

```jsx
<Button onClick={handlerFunction}></Button>
```

Rapidamentes nos podemos percatar como es que la sintaxis es muy parecida.

A pesar de esto debemos tomar en cuenta varias consideraciones al momento de trabajar con eventos mediante React que en los proximos capitulos abordaremos.

### Asignacion de eventos

Como mencionamos en la seccion anterior la asignacion de eventos a elementos _jsx_ se hace de una manera muy similar a la de _html_ nativo.

```jsx
//sintaxis
<jsxElement onEvent={handlerFunction}> </jsxElement>
```

Donde:
- jsxElement: Elemento html declarado con la sintaxis jsx.
- onEvent: Evento que se le asignara al elemento html.
- handlerFunction: Funcion manejadora que ejecutara el elemento cuando se desencadene el evento asociado a el.

### onEvents

Jsx nos ofrece la sintaxis `onEvent` para asignación de eventos a los elementos jsx, debemos anteponer la palabra _"on"_ seguida del nombre del evento para declarar un evento, por ejemplo : "onClick", "onScroll", "onChange", "onSubmit"... etc.

A pesar de que en React estan disponibles la mayoria de eventos disponibles en _Javascript_ nativo, no quiere decir que lo esten todos por lo que hay que estar atentos con aquellos que no esten soportados (leer la documentación).

### handlerFunctions

Una handlerFunction, no es otra cosa que una funcion (metodo en el caso de componentes de clase) que se le asignara al evento del elemento jsx y que se ejecutara cuando dicho evento se dispare en el navegador.

Este apartado es muy importante ya que debemos tener nocion de lo que ocurre al momento de asignar una función a los eventos de los elementos.

Al estar trabajando con componentes de **_clase_** debemos tener en cuenta que una clase en Javascript se ejecuta en modo estricto, de tal manera que si una funcion no puede hacer referencia al contexto de la clase el valor de _this_ sera: _undefinded_. Con lo cual se pierde el contexto de ejecución de la función y al querer acceder a cualquier propiedad de la clase (Componente de clase) no lo podremos hacer.

**Ejemplo**

En este ejemplo haremos un contador que aumenta, el valor del _state_ _counter_, para esto añadiremos dos botones que se encargaran de sumar o restar el valor del state asignandoles eventos.

```jsx
import React, {Component} from 'react';

export default class EventosEjemplo extends Component{
	constructor(props){
		super(props);
		this.state = {
			counter : 0
		}
	}
	
	render(){
		return(
			<>
				<h2>Ejemplo Eventos<h2/>
				<h3>{this.state.counter}</h3>
				<button>Add</button>
				<button>Sub</button>
			</>
		)
	}
}
```

Añadimos las funciones manejadores (add, sub).

```jsx
import React, {Component} from 'react';

export default class EventosEjemplo extends Component{
	constructor(props){
		super(props);
		this.state = {
			counter : 0
		}
	}
	//handler functions
	sub(){
		console.log(this.state.counter);
	}
	
	sub(){
		console.log(this.state.counter);
	}
	
	render(){
		return(
			<>
				<h2>Ejemplo Eventos<h2/>
				<h3>{this.state.counter}</h3>
				<button>Add</button>
				<button>Sub</button>
			</>
		)
	}
}
```

Asignamos los eventos y las funciones manejadoras a los botones.

```jsx
import React, {Component} from 'react';

export default class EventosEjemplo extends Component{
	constructor(props){
		super(props);
		this.state = {
			counter : 0
		}
	}
	//handler functions/methods
	add(){
		console.log(this.state.counter);
	}
	
	sub(){
		console.log(this.state.counter);
	}
	
	render(){
		return(
			<>
				<h2>Ejemplo Eventos</h2>
				<h3>{this.state.counter}</h3>
				//funciones manejadoras y eventos
				<button onClick={this.add}>Add</button>
				<button onClick={this.sub}>Sub</button>
			</>
		)
	}
}
```

Si intentamos hacer click en alguno de los dos botones:

![[Pasted image 20241118002143.png]]

Vemos como obtenemos un error o _undefined_, como bien sabemos la palabra _this_ en javascript se comporta de manera muy diferente respecto a otros lenguajes de programacion debemos tener en cuenta que _this_ toma el contexto de la ejecucion por lo que su valor puede variar incluso si los metodos/funciones pertenecen a una misma clase como sucede en este caso.

En este ejemplo cuando asignamos `this.add y this.sub` a los eventos de los botones hacemos referencia a los metodos de la misma clase con lo cual aun hay referencia al contexto de la misma clase sin embargo cuando se ejecuta el codigo de los metodos: 

`console.log(this.state.counter);`

Se pierde la referencia de `this` dado que el contexto de la ejecucion de los metodos/funciones no se da originado por un objeto de la clase sino en el contexto de los eventos de los botones.

### event binding

Para evitar la perdida del contexto en los eventos de clase tenemos que implementar un _event binding_

```jsx
import React, {Component} from 'react';

export default class EventosEjemplo extends Component{
	constructor(props){
		super(props);
		this.state = {
			counter : 0
		}
		//event binging
		this.sub = this.sub.bind(this);
		this.add = this.add.bind(this);
	}
	//handler functions/methods
	add(){
		console.log(this.state.counter);
	}
	
	sub(){
		console.log(this.state.counter);
	}
	
	render(){
		return(
			<>
				<h2>Ejemplo Eventos</h2>
				<h3>{this.state.counter}</h3>
				//funciones manejadoras y eventos
				<button onClick={this.add}>Add</button>
				<button onClick={this.sub}>Sub</button>
			</>
		)
	}
}
```


### binding con arrow functions

Una de las ventajas de las funciones flecha es que estas recuerdan el contexto de su elemento padre.

```jsx
import React, {Component} from 'react';

export default class EventosEjemplo extends Component{
	constructor(props){
		super(props);
		this.state = {
			counter : 0
		}
	}
	//handler functions/methods
	//event binding con funciones flecha
	add = ()=> {
		console.log(this.state.counter);
	}
	
	sub = ()=> {
		console.log(this.state.counter);
	}
	
	render(){
		return(
			<>
				<h2>Ejemplo Eventos</h2>
				<h3>{this.state.counter}</h3>
				//funciones manejadoras y eventos
				<button onClick={this.add}>Add</button>
				<button onClick={this.sub}>Sub</button>
			</>
		)
	}
}
```

### Parametro (e)

Si requerimos informacion sobre el evento y quien lo origina podemos pasar el parámetro "e" a las funciones manejadoras.

```jsx
//bind
handlerFunction(e){

}
//arrow
handlerArrow = (e) => {
	//do something
}
```

Y en la asignacion del eventHandler al evento tambien pasar dicho argumento.

```jsx
<button onClick={e=>handlerFunction}></button>
```


El argumetno "e" en react es diferente al event "e" de javscript vanilla, ya que React lo que hace es envolver en una capa externa el manejo del evento original para dar soporte a todos lo navegadores de tal manera que cuando accedemos al parametro "e" del event no obtenemos el event original de JavaScript sino a esta capa llamada: `syntethic.event`.

Si queremos acceder al event original lo podremos hacer mediante la propiedad : `e.nativeEvent`.

### Paso de parámetros

Si es requerido podemos enviar valores desde el evento a las funciones manejadoras, solo basta con envolver al llamado de la funcion manejadora con otra funcion para pasarle los parametros.

```jsx
<button onClick = {(e)=>handlerFunction(e,"Hello world")}></button>
```

Y manejar dicho valor desde la handler function.

```jsx
handlerFunction = (e,str)=>{
	console.log(str);
}
```


## 2.2.5 Renderizado

### Condicional

### Listas 

---

# 3.1 Componentes funcionales

Un componente funcional es aquel definido mediante la sintaxis de funciones.

**Caracteristicas:**

+ Todo se define dentro del cuerpo de la funcion.
+ No es necesario importar {Component}, solo basta con importar React.
+ No tienen un _state_ como los componentes de clase, en su lugar se complemenetan con los **_hooks_** para proporcionarle estado a los componentes funcionales.
+ No tienen un ciclo de vida como lo tienen los componentes de clase, sin embargo gracias al uso de la funcion **_useEffects_** o "efectos" podemos simular un ciclo de vida.
+ No tiene un metodo render(), en su lugar  usamos el return de la funcion para simular el metodo render() de los componentes de clase, por lo que los elementos que van a conformar a nuestro componente se deberan definir en el return de nuestro componente funcional.

**Estructura básica de un componente Funcional**

```jsx
import React from 'react';

export default function FunctionalComponent(props){

	return{(
		<>
			<h2>Hello World!</h2>
		</>
	)};
}
```



## 3.1  Construir componente funcional

**Paso 1:** Definir una funcion
Definimos una función, esta función debe hacer uso de la sintaxis UpperCamelCase para que React la reconozca.

```jsx
import React from 'react';

function Profile(){

}
```

**Paso 2:** Agregar marcado JSX
Agregar marcado _html_ con las sintaxis **JSX**. Recordemos que la sintaxis JSX es una sintaxis especial de React que nos permite incorporar marcado _html_ dentro de Javascript.

```jsx
function Profile(){
	return <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />;
}
```

>Nota si el codigo JSX ocupa mas lineas es necesario encerrarlo dentro de parentesis para retornarlo.

```jsx
function Profile(){
	return(
		<div>
			<img src="imagen.jpg" alt="Kath Jhonson">
		</div>
	)
}
```

**Paso 3:** Exportar el componente

Debajo de la definicion de nuestro componente, debemos exportar nuestra funcion con la sintaxis de Javascript (export default functionName).

```jsx
function Profile(){
	return(
		<div>
			<img src="imagen.jpg" alt="Kath Jhonson">
		</div>
	)
}
export default Profile;

```

## 3.2 Hooks

### 3.2.1 Estado: useState()

Como mencionamos en las características generales de los componentes funcionales, estos no cuentan con un _state_ como los componentes de clase sin embargo esto ha cambiado con las ultimas versiones de React, ya que ahora es posible manejar variables de estado en los componentes funcionales mediante el uso de la función `useState()`.

La función useState() nos permite declarar variables de estado, de tal manera que el cambio o modificación de estas va a desencadenar un nuevo renderizado del componente al que pertenecen.

>Nota: podemos tener tantas variables state como lo requiera nuestra aplicación.

**Sintaxis de useState**

Al momento de definir un _state_ se recomienda nombrarlos como (estado) y (setEstado).

```jsx
//sintaxis basica de useState
const [myState, setMyState] = useState(initialState);
```

`useState` devuelve un _array_ con exactamente dos valores:

1. (myState): El estado actual . Durante el primer renderizado, coincidirá con el `initialState` que hayas pasado.
2. (setMyState): La [función `set`](https://es.react.dev/reference/react/useState#setstate)  que te permite actualizar el estado a un valor diferente y desencadenar un nuevo renderizado. Esta función recibe como parámetro el nuevo valor del state a modificar.

#### state y setState

Como se menciona useState devuelve un array con dos valores:
+ state: Valor inicial del state le es asignado mediante el parametro initialState.
+ setState: Una funcion que debemos llamar para poder modificar el state, hay que recordar que en un componente el state no puede ser modificado directamente solamente a través de una función setState.


```jsx
//declaracion de un state
//declara el state count con un valor inicial de 0
const [count, setCount] = useState(0);

//llamado a setCount
//establece el valor del state count a 27
setCount(27);
```

#### Modificando el estado

Podemos obtener el estado actual simplemente refiriéndonos a la variable de estado.

```jsx
const [count, setCount] = useState(0);
console.log(count)
//0
```

Si queremos modificar el valor del state actual simplemente llamamos a nuestra funcion set y le pasamos el valor nuevo.

```jsx
const [count, setCount] = useState(0);
setCount(27);
console.log(count)
//27
```

Si quisieramos modificar el state tomando como referencia el valor actual, la lógica nos dice que deberíamos hacer algo como lo siguiente:

```jsx
const [count, setCount] = useState(0);
setCount(count + 1);
setCount(count + 1);
setCount(count + 1);
console.log(count);
//result: 1
```

Lo cual tiene sentido, sin embargo podemos observar que el resultado es "1" en lugar de "3", esto es un comportamiento de React el cual se explica en la documentacion de la siguiente manera:

>Nota: La función `set` **solo actualiza la variable de estado para el _próximo_ renderizado**. Si lees la variable de estado después de llamar a la función `set`, [seguirás obteniendo el valor anterior](https://es.react.dev/reference/react/useState#ive-updated-the-state-but-logging-gives-me-the-old-value) que estaba en la pantalla antes de tu llamada.

De ahi que obtengamos el valor de "1", otra consideracion importante es la siguiente:

>Si el nuevo valor que proporcionas es idéntico al `estado` actual, según lo determinado por un [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is), React **omitirá volver a renderizar el componente y sus hijos.** Esta es una optimización. Aunque en algunos casos React aún puede necesitar llamar a tu componente antes de omitir los hijos, no debería afectar tu código.

#### Multiples modificaciones del state

Como vimos en la seccion anterior el comportamiento de react nos permite actualizar el valor del state en una sola ocasion por cada llamado a nuestras funciones setState, si deseamos actualizar el valor del estado varias veces hay que tomar en cuenta lo siguiente:

>Si pasas una función como `siguienteEstado`, se tratará como una _función de actualización_. Debe ser pura, debe tomar el estado pendiente como único argumento y debe devolver el siguiente estado. React pondrá tu función de actualización en una cola y volverá a renderizar tu componente. Durante el próximo renderizado, React calculará el siguiente estado aplicando todas las actualizaciones en cola al estado anterior. [Ve un ejemplo debajo.](https://es.react.dev/reference/react/useState#updating-state-based-on-the-previous-state)

Resumiendo tenemos que enviar como parametro una funcion a la funcion setState, dicha funcion puede ser una funcion flecha anonima con un único argumento (la variable de estado).

```jsx
setState((prevState)=> prevState + 1);
```

Ejemplo:

```jsx
const [count, setCount] = useState(0);
setCount( (prevCount) => prevCount + 1);
setCount( (prevCount) => prevCount + 1);
setCount( (prevCount) => prevCount + 1);
console.log(count);
//result: 3
```

Mediante este metodo de actualizacion tendremos el resultado deseado, como menciona la documentacion de react todas estas llamadas son enviadas a una cola en la cual se ejecuta la actualizacion del _state_ y solo se ejecuta un renderizado por actulizacion del _state_.

Este metodo de actualizacion es muy util cuando queramos actualizar el _State_ tomando en cuenta el valor actual.

Por ejemplo si nuestra variable de estado almacena un array de objetos y se requiere poblar dicho array con nuevos objetos, es necesario usar este metodo de actualizacion para conservar todos los objetos.

#### Ejemplo state Contador

En el siguiente componente se declara un variable de estado `count` que invocara el renderizado del componente en cada actualizacion del valor, para esto al elemento `<button>` se le asigna un evento _click_ que invoca a la funcion manejadora `add()` que actualiza el valor de `count` mediante el llamado de `setCount()`.

```jsx
import React, {useState} from 'react';

export default function Counter(props){
	//variable de estado=state
	const [counter, setCounter] = useState(0);

	//handlerFunction
	const add = () => {
		setCounter(counter + 1);
	}
	return(
		<>
			<h2>State con setState()</h2>
			<h3>{counter}</h3>
			<button onClick={add}>Counter</button>
		</>
	);
}
```


### 3.2.2 Ciclo de vida y useEffect

Otra de las caracteristicas de los componentes funcionales, es la ausencia de un ciclo de vida explicito como el de los componentes de clase. A pesar de esto las nuevas versiones de react nos ofrecen la funcion `useEffect()` con la cual podemos simular un ciclo de vida.

#### Invocar useEffect()

Para usar `useEffect()` debemos importar desde react:

```jsx
import React {useEffect} from 'react';
```

Cuerpo de useEffect().

```jsx
useEffec(()=>{
	//body function

	//unmount function
	return ()=>{
	}
},[state])
```

`useEfect()` es una funcion que recibe los siguientes parametros:

+ Una funcion en la cual se ejecutara toda la logica que queramos que se ejecute al cambio de las variables del estado. Dentro de esta funcion podemos retornar otra funcion en la cual podremos definir el codigo necesario para desenlazar llamadas a API's, servicios/conexiones o eventos.
+ Un array con la variable/s de estado que queramos que dicho effect tome en cuenta para que que ejecute su codigo cuando ocurra un cambio en dicha variable de estado.

#### Simulando ciclo de vida

Si hacemos una comparacion con los metodos del ciclo de vida de los componentes de clase con la funcion `useEffect()`  de los componentes funcionales, podremos ver como simular dicho ciclo de vida.

**Ciclo de vida componentes de Clase**

```jsx
class ClassComponent extends Component{
	// F0: Inicializacion: el componente se inicializa no esta 
	//en el DOM
	constructor(props){
		super(props);
		this.state={}
	}
	//F1: Fase de carga
	//el componente ya se encuentra en el DOM
	componentDidMount(){
	}
	//F2: Fase de actualizacion
	//el state del componente cambia
	componentDidUpdate(){
	}
	
	//F3: Fase de eliminacion
	//el componente ha sido removido del DOM
	componentWillUnmount(){
	
	}
	
	//F4:
	//el componente ha sufrido un cambio y se renderiza en el DOM
	render(){
	}
}
```

**Componentes funcionales**

```jsx
import React, {useState, useEffect} from 'react'

function FunctionalComponent(props){
	//F1: inicializacion
	const [count, setCount] = useState(0);
	
	//simulando ciclo de vida
	useEffect(()=>{
		/*
			F3: componentDidUpdate()
			
			Todo el codigo antes del return se ejecutara ante 
			un cambio en la variable de estado del array del 
			segundo parametro
		*/
		return ()=>{
		/*
			F4: componentWillUnmount()

			Cuando un componente ya no sea visible en el DOM
			podremos ejecutar codigo en el return para realizar
			operaciones de liberacion a ciertos recuros, como
			conexiones a API's, DB's, eventListeners, etc...
		*/
		}
	},[count]);

	/*
		F2: componentDidUnmount()

		Si queremos simular esta fase, es decir ejecutar
		codigo una sola vez antes del montado del componente 
		en el DOM, simplemente tenemos que declarar otro effect
		con el array como parametro vacio.
	*/
	useEffect(()=>{
	},[])
}
```
### 3.2.3 Hooks Personalizados

Una de las ventajas de `useEffect()` y react, es que nos permite crear nuestros propios **_effects_** personalizados ideal para refactorizar y re-utilizar codigo que se utiliza en varias ocasiones.

Para implementar nuestros _effects_ personalizados debemos tomar en cuenta lo siguiente:

+ Declararlos en archivos independientes.
+ Nombrarlos con anteponiendo la palabra "use" seguida del nombre que le queramos dar a nuestro _effect_.

**Ejemplo _effect_ personalizado**

```jsx
import { useState, useEffect } from "react";
/*
    custom hook
    Para solicitar informacion a traves de fetch a una API
*/

export function useFetch(url){
    // state variables
    //almacena los datos recibidos por la peticion
    const [data, setData] = useState(null);
    //state para verificar el estado de la peticion
    const [isPending, setIsPending] = useState(true);
    //const para almacenar el error
    const [error, setError] = useState(null);
    
    useEffect(()=>{
        const getData = async ()=> {
            try{
                let res = await fetch(url);
                //validacion de errores
                if(!res.ok){
                    throw {
                        error: true,
                        status : res.status,
                        message : !res.statusText ? "Ocurrio un Error" : res.statusText

                    }
                }
                let data = await res.json();
                setData(data);
                setIsPending(false);
                setError({error: false});
            }catch(err){
                // setData(data);
                setIsPending(true);
                setError(err);
            }
        }
        //
        getData(url);
        //el state a observar va a ser la url
    },[url]);
    //retornamos:
    return {data, isPending, error};
}
```



## 2.4 Importar Component de React

Aunque en versiones mas actuales de react (>17) no es necesario hacer el import de Component de React, se considera una buena practica hacerlo.

Para esto solo basta con realizar un import con la sintaxis que utilizamos con Javascript para imoprtar funciones que han sido declaradas en archivos ".js" externos.

Debemos agregar a la definicion de nuestros componente la siguiente linea:

>import React, {Component} from "react";

## 2.5 Usar componentes


---


# 4. Referencias

Para el manejo de elementos del DOM que ya han sido cargados y que su contenido no va a verse afectado o que no tienen _state_, React nos ofrece las referencias, de tal manera que en lugar de usar metodos de Vanilla Js como `getElementById()` o `querySelector()` usaremos la funcion `useRef()` de react para almacenarlo en una variable y poder acceder a sus propieadades y metodos para su manipulacion.

## Sintaxis

Debemos crear una variable asignándole la función `useRef()` y dicha variable asignársela como propiedad a los elementos jsx de nuestro componente mediante la prop `ref={}`;

```jsx
const botonRef = useRef();

<button ref={botonRef}></button>
```

De esta manera podremos hacer uso de las propiedades y atributos del dicho elemento del DOM, claro despues de que este se renderize.

## Ejemplo

En vanilla js tendriamos que hacer algo como lo siguiente para almacenar un elemento del DOM y poder manipularlo mediante javascript.

**Vanilla JS**

```js
//vanilla js
const menuBtn = document.querySelector(".btn-menu");
const menuEl = document.querySelector(".menu")

menuBtn.addEventListener("click",e=>{
	if(refBoton.current.textContent === "Menu"){
		 refBoton.current.textContent = "Cerrar";
	     refMenu.current.style.display = "block";
    }
    else{
	    refBoton.current.textContent = "Menu";
        refMenu.current.style.display = "none";
    }
});
```

Mientras que en React con el uso de la funcion `useRef()` hacemos referencia al elemento del DOM de nuestro componente.
**React**

```js
//react js
function Menu(){
	//asignacion de use Ref
	const menuBtn = useRef();
	const menuEl = useRef();

	const hadleMenu = ()=> {
		if(refBoton.current.textContent === "Menu"){
		//accedemos a las propiedeaes del elemento mediante
		//las refs
			 refBoton.current.textContent = "Cerrar";
		     refMenu.current.style.display = "block";
	    }
	    else{
		    refBoton.current.textContent = "Menu";
	        refMenu.current.style.display = "none";
	    }
	}

	return(
	<>
		<h2>Referencias</h2>
		//asignacion de las variables ref en la props del elemento
        <button onClick={handleToggleMenu} ref={refBoton}>
	        Menu
        </button>
        <nav style={{display:"none"}} ref={refMenu}>
            <a href="#">Seccion 1</a>
            <br />
            <a href="#">Seccion 2</a>
            <br />
            <a href="#">Seccion 3</a>
            <br />
		    <a href="#">Seccion 4</a>
		</nav>
	</>
	)
}
```

---

# 5. Formularios 


## 5.1 Metodo onChange


## 5.2 Objeto state



---

# 6. Estilos

## 6.1 CSS

### Hojas de estilos

### Estilos Inline

### Module Styles

### @normalize (webpack)

### sass


## 6.2 Styled Components

---

# 7. Children Components

La propiedad `children` hace referencia al contenido interno de un componente. Es una forma diferente de poder definir el contenido (HTML o componentes) dentro de un componente.

**Ejemplo**

Si tuviéramos un componente para generar elementos de tipo `article`, como se muestra a continuación:

```jsx
//
function Articulo(props){
	return (
		<article classForm="articulo">
			<h2>{props.title}</h2>
			<p>{props.content}</p>
			<img src={props.img}>
		</article>
	)
}
```

Al momento de utilizar dicho componente en cualquier otra parte de nuestra aplicación tendríamos que pasar el contenido para generar el articulo mediante las propiedades del componente.

```jsx
//test componente articulos
function App(){
	return(
		<section classForm="articulos">
		//componente Articulo
			<Articulo title="Hello World" content="Lorem Ipsum" 
				img="https://image-test.png>
			</Articulo>
		</section>
	);
}
export default App();
```

Sin embargo mediante la propiedad `children`, la cual es una propiedad especial que todo los componentes de _React_ tienen, podemos generar el contenido dentro de la definicion de nuestro componente principal. Es decir, podemos anidar componentes o elementos mediante la sintaxis **jsx** dentro del llamado de nuestro componente principal y renderizarlos dentro del metodo `render` (componentes de clase) o en el `return` (componentes funcionales).

Para realizar esto debemos cambiar un poco nuestro componente Articulo. Debemos cambiar el argumento de nuestro componente funcional para que reciba un objeto "destructurado" con una propiedad llamada "_children_" si el componente necesita aun necesita recibir "propiedades" igual las debemos destructurar para poder acceder a ellas.

> Nota: `children`, es una propiedad especial de los componentes de React por lo que para hacer uso de ella debemos declararla exactamente con el nombre de "children". Al momento de hacer uso de ella dentro del componente, React sabra que se trata de elementos jsx u otros componentes que se tienen que renderizar.

Una vez que hemos hecho el cambio del argumento de nuestro componente funcional, podemos hacer uso de el dentro de nuestro componente simplemente llamandolo en la parte que necesitemos.

En este caso eliminamos los elementos definidos anteriormente y lo remplazamos por nuestra propiedad "children".

```jsx
//
function Articulo({children}){
	return (
		<article classForm="articulo">
			{//old}
			{/*<h2>{props.title}</h2>
			<p>{props.content}</p>
			<img src={props.img}>*/}
			
			{//new}
			{children}
		</article>
	)
}
```

Como ahora vamos a definir el contenido de nuestro componente al momento de hacer uso de el, por lo que tambien debemos cambiar la declaración al momento de usarlo.

```jsx
//test componente articulos
function App(){
	return(
		<section classForm="articulos">
		{//componente Articulo}
			<Articulo title="Hello World" content="Lorem Ipsum" 
				{//ahora definimos aqui el contenido del componente}
				<h2>{props.title}</h2>
				<p>{props.content}</p>
				<img src={props.img}>
			</Articulo>
		</section>
	);
}
export default App();
```

De esta manera podemos crear componentes contenedores o wrappers, los cuales nos van a servir para poder añadir contenido de todo tipo y el cual puede variar, ademas de que tambien pueden tener funcionamiento. Este es un ejemplo muy basico, sin embargo se pueden crear componentes mas complejos. 

----

# 8. Portales

Los portales en React nos sirven para poder renderizar componentes de React en nodos _html_ diferentes al nodo principal.

>**Nota**: Los metodos para crear portales (ReactDOM.createPortal y createPortal) esta dentro de "reac-dom".

Por lo general en una aplicacion _react_, se suele utilizar un solo nodo _html_ para renderizar el contenido de la aplicacion sin embargo habra ocasiones en las que se habra necesidad de renderizar contenido en en algun elemento _html_ diferente al principal, para estos casos podemos hacer el uso de portales que nos permiten renderizar contenido en nodos diferentes al principal.

## ReactDOM.createPortal y createPortal

React nos facilita dos funciones dentro de la API "react-dom" para renderizar contenido en dicho elemento.

1. ReactDOM.createPortal(components, parent);
2. createPortal(components, parent);

En esencia ambas funciones realizan la misma funcion (renderizar componentes de react en un nodo html diferente al principal) pero hay que tomar en consideracion que ``ReactDOM.createPortal`` ha dejado de recibir soporte y por ende en versiones de react mayores a la 17.0 no se recomienda su uso, al usarla la aplicacion en desarrollo se comportara como  si estuviera usando React 17.0 aunque estemos usando versiones de React mas actuales.

La version actual de `ReactDOM.createPortal()` es `createPortal()`, realizan la misma tarea y al ser una version mucho mas actualizada contiene mejoras por lo que se recomienda su uso.

## Ejemplo

En una aplicacion React tenemos un archivo ``index.html`` el cual contiene un elemento html con el id donde se renderizara el contenido de nuestra aplicacion, en este ejemplo es el elemento div con el id "root".

```html
<!DOCTYPE html>
<html>
  <head>
    <title>React Vite Micro App</title>
  </head>
  <body>
	<div id="modal-portal"></div>
    <div id="root"></div>
    <script type="module" src="./src/index.jsx"></script>
  </body>
</html>
```

Sin embargo si quisiéramos renderizar componentes de React en el elemento `div` con el id "modal-portal", tendríamos que hacer uso de portales.

Supongamos el siguiente Componente:

```jsx
function Articulo({children}){
	return (
		<article classForm="articulo">
			{//old}
			{/*<h2>{props.title}</h2>
			<p>{props.content}</p>
			<img src={props.img}>*/}
			
			{//new}
			{children}
		</article>
	)
}
```

Si quisieramos renderizarlo en el elemento html `<div id="modal-portal"></div>` tendriamos que llamar a la funcion `createPortal()` en el return de nuestro componente y pasar como argumento de la funcion, los componentes a renderizar y el nodo html donde se renderizaran.

```jsx
createPortal(<Componentes></Componetes>, targetElement);
```


```jsx
//importar createPortal desde "react-dom"
import {createPortal} from "react-dom";

function Articulo(){
	return createPortal(
		<article classForm="articulo">
			<h3>Modal Con Portales</h3>
            <p>Este es el contenido de la ventana modal</p>
            <img src={imagen} alt="whales ink"/>
		</article>,
		document.getElementById("modal-portal")
	)
}
```

La sintaxis es la misma para `ReactDOM.createPortal()`.

```jsx
//importar ReactDOM desde "react-dom"
import ReactDOM from "react-dom";

function Articulo(){
	return ReactDOM.createPortal(
		<article classForm="articulo">
			<h3>Modal Con Portales</h3>
            <p>Este es el contenido de la ventana modal</p>
            <img src={imagen} alt="whales ink"/>
		</article>,
		document.getElementById("modal-portal")
	)
}
```

---

# 9. React Router

Antes de comenzar a explicar el funcionamiento de react-router, debemos comprender como es que son renderizadas las aplicaciones (SPA) con react.

En una aplicacion o pagina web tradicional que no haga uso de react, cuando hacemos "_click_" sobre algun _link_ el navegador envia una peticion al servidor y el contenido es renderizado cuando el servidor devuelve una respuesta.

Mientras que en aplicaciones desarrolladas con react siguiendo la filosofia (SPA), react intercepta todas esas peticiones enviadas al servidor y renderiza el contenido dinamicamente a partir de los componentes que se crearon en el desarrollo de la aplicacion.

Esta es la idea general detras de las SPA's, nos permiten renderizar el contenido de manera mucho mas rapida y sin necesidad de actualizar la pagina.

En un proyecto de react, siempre tendremos un fichero llamado `index.html` dentro del directorio ``public``, todo el codigo de definido dentro del fichero `App.jsx` se renderizara dentro del fichero `index.html`. Esto significa que en nuestra aplicacion react solo existe un fichero html en el cual se renderiza todo el contenido.

¿Que sucede cuando tenemos un componente diferente y quisieramos renderizarlo como una pagina diferente?, ¿Creamos un nuevo fichero html para renderizarlo?

La respuesta es no, en este caso React-Router, nos ayuda a direccionar/navegar hacia dicho componente y renderizarlo en el mismo fichero `index.html`.

Asi que cuando navegamos a traves de una SPA, no navegamos a diferentes ficheros `html` devueltos por el servidor, sino a un nuevo componente que reescribe el contenido del fichero `index.html`.


## 9.1 Instalacion

Instalación para proyectos react-web.

>npm install react-router-dom


Instalacion para proyectos react-native:

>npm install react-route

## 9.2 Componentes para Rutas

La librería react-router nos ofrece componentes para el manejo de rutas. Estos componentes nos permiten generar las rutas y enlazarlas a los componentes que nostros hayamos definido para que sean renderizados al acceder a dichas rutas.

### ReactBrowser

### Router

### Routes

El componente `Route` recibe dos propiedades `path` y `element`
Propiedades, es el encargado de definir las rutas y establecer que elemento se va renderizar cuando accedamos a dichas rutas.

```jsx
<Route path="/route-name" element={component}></Route>
```

- path : Es el nombre de la ruta la cual nos va a permitir acceder al componente enlazado a el. Esta ruta siempre debera comenzar con un "/" seguido del nombre de la ruta.
- element : El componente o etiqueta jsx a renderizar.

## 9.3 Componentes de navegación

Cuando definimos una ruta mediante ``BrowserRouter``, ``Routes`` y ``Route``, podemos acceder a dicha ruta escribiéndola directamente la url en el navegador, por ejemplo:

> localhost:5173/services

Sin embargo eso no es muy practico, lo ideal seria hacerlo mediante "links" o "enlaces" como lo haríamos en una pagina o aplicación web tradicional pero al estar desarrollando la aplicacion con react y no podemos hacer uso del elemento ``<a></a>`` de _html_, sin embargo react-router nos ofrece los componentes ``<Link/>`` y ``<LinkTo/>`` que tienen la misma funcionalidad del elemento ``<a></a>`` pero nos permiten navegar mediante las rutas definidas con react-router.

Estos componentes nos permiten navegar a través de las rutas definidas, tienen una funcionalidad similar al elemento `<a></a>` de _html_ es decir, nos permiten generar _links_ para navegar y acceder a las rutas definidas en nuestro proyecto.
### Link

El componente `Link` nos permite renderizar un "ancla" o "link" de navegación, cuando el usuario haga click sobre el react renderizara el componente al cual este enlazada dicha ruta.

**params**
- to : La ruta a la cual se dirigirá dicho link.
- Name : El nombre de la ruta.

```jsx
import {Link} from 'react-router-dom'
<Link to="">Name</Link>
```

### NavLink

El componente `LinkTo` tiene la misma funcionalidad que `Link`, sin embargo `LinkTo` cuenta con una propiedad llamada _isActive_ la cual es de tipo boolean y su valor depende de si la ruta a la cual se accedio se esta visualizando o no por ende cuando accedemos a una ruta su valor sera _true_ y _false_ cuando ya no la estemos visualizando o hayamos cambiado de ruta.

Permite los mismos parametros que `Link`.

**params**:

- to: La ruta a la cual se dirigira.
- isActive: Propiedad que podremos evaluar para ejecutar codigo dependiendo de su valor.
- Name: El nombre de la ruta.

```jsx
import {LinkTo} from 'react-router-dom'

<LinkTo to="/route" isActive={isActive}>Name</LinkTo>
```

Uno de los usos que le podemos dar a  `LinkTo`, es evaluar la propiedad _isActive_ para aplicar determinados estilos.

**Ejemplo**

Podemos añadir una clase con estilos determinados para indicar en un menu de navegacion la ruta actual en la que nos encontramos.

```jsx
import {LinkTo} from 'react-router-dom'
export function Menu(){
	return(
	<nav className='menu'>
       <NavLink to="/" className={({isActive}) => isActive ? "active-link" : null }>Home</NavLink>
          <NavLink to="/acerca" className={({isActive}) => isActive ? "active-link" : null }>Acerca</NavLink>
          <NavLink to="/contacto" className={({isActive}) => isActive ? "active-link" : null }>Contacto</NavLink>
        </nav>
	)
}
```

En el ejemplo anterior evaluamos _isActive_ para añadirle la clase "active-link" de css al `Link` activo.

## 9.4 Crear rutas

Para crear las rutas de navegación necesitaremos crear un componente BrowserRoute anidar un componente Routes y dentro de este ultimo definiremos las rutas con el componente Route.

>Nota: Debemos hacer la definicion de las rutas dentro del archivo App.jsx

```jsx
//importar
import {ReactBrowser, Routes, Router} from 'react-router-dom'

//rutas
<BrowserRoute>
	<Routes>
		<Route path="/" element="{<h1>Home</h1>}"></Route>
		<Route path="/about" element={<About></About>}></Route>
		<Route path="/contact" element={<Contact></Contact>}></Route>
	</Routes>
</BrowserRoute>
```

Una vez definidas las rutas, para acceder o navegar entre ellas debemos hacer uso del componente `Link` o `LinkTo` para renderizar links de navegacion como lo hariamos con el elemento `<a></a>` de html.

Este paso se puede hacer fuera del componente `App` ya que por lo general estos "links" seran componentes que se renderizaran como parte de otros componentes mas generales como un menu de navegacion.

Lo que debemos recordar es que el parametro `to` de `Link` o `LinkTo` debera ser una de las rutas definidas en nuestro componente `BrowserRoute`.

Ejemplo:

```jsx
import {Linkt} from 'react-route'

<Link to="/">Home</Link>
<Link to="/about">Acerca de</Link>
<Link to="/contact">Contacto</Link>
```


### 9.4.1 Sobre las rutas

Al momento de definir las rutas debemos tomar en consideracion lo siguiente:

- La ruta "/" indica el home o inicio de nuestra aplicacion.
- Iniciar toda ruta con una diagonal "/"+"nombre"
- Usar nombres en formato lower-case

## 9.5 Url's Dinamicas

Una de las características fundamentales de cualquier aplicacion es poder generar `Links` o "urls" dinamicas. Esto lo podemos lograr a partir de las sintaxis que nos ofrece "react-router" y del _hook_ useParams.

Pasos para definir urls dinamicas:

1. Redefinir la ruta para que acepte "route params".
2. Declarar links con los valores a enviar a traves de la url.
3. Leer el valor de la url para renderizar el componente con la informacion adecuada.

### Route params

Los parametros de ruta (route params) son aquellos valores que podemos enviar a traves de una url definida en alguna ruta.

Para poder habilitar el paso de valores a traves de una ruta debemos cambiar la declaracion de la misma para que acepte y reconozca cuando se le envian valores dinamicamente.

Veamos la siguiente ruta para explicarlo: 

```jsx
<Route path="/products/:id" element={<ProductDetail/>}></Route>
```

Si somos atentos podremos observar como hemos añadido `/:id` al final de la declaracion del path de nuestra ruta "products", cuando hacemos esta declaracion le estamos diciendo a "react-router" que dicha ruta aceptara el paso de parametros a traves de la url. 

Si queremos generar "url's" dinamicas lo que necesitamos hacer es añadir los dos puntos "/:" seguido del nombre de la variable al final del path de nuestra ruta.

>Nota: Cuando definimos "/:" le indicamos a react-router que dicho valor se trata de una parámetro de ruta.

### Enviar params

Una de las maneras sencillas para enviar route-params es generar componentes `Link` con la ruta y el valor a enviar a través de ella.

Siguiendo con el ejemplo de nuestra ruta "productos", podriamos definir una lista de `Links` con dicha ruta y valor.

Supongamos que despues de llamar a una API, esta nos devuelve una lista con todos los productos y su id, para que el usuario pueda acceder a los detalles de cada producto generaremos links dinamicamente con la ruta hacia los productos seguidos de su id.


```jsx
import { Link } from "react-router-dom"

export function Productos(){
	const productos = fakeApi.getProducts();
    return (
        <section>
            <h1>Productos</h1>
            <ul className="productos">
                {productos.map(prod => (
                    <li key={prod.id}>
                        <Link to={`/productos/${prod.nombre}`}>{prod.nombre}</Link>
                    </li>
                ))}
            </ul>
        </section>
    )
}
```

Vemos como obtenemos el valor de "id" y "name" de un objeto "prod", esto podria ser generado dinamicamente como resultado de una solicitud a un API externa.

### Obtner params (useParam)

Para obtener el valor enviado a través de la url "react-router" nos ofrece el "hook" `useParam` el cual es un objeto que contiene el valor enviado a traves de la url.

Este valor es de importancia dado que mediante este podremos renderizar el componente con la información que le pertenece. En nuestro ejemplo renderizaremos la información del producto mediante el "id" enviado a traves de la url.


```jsx
import {useParams} from 'react-router-dom'

function ProductDetail(){
	//leemos el valor enviado a traves de la url, que se almacena
	//en el hook useParams de react-router-dom
	//destructuramos
	const {id} = useParams();
	//hacemos una peticion a una api para obtener la info del
	//producto a partir del id enviado mediante la url
	const product = callSomeApi(id);
	
	//definicion del componente a renderizar
	//y mostramos la info del producto
	return(
		<section>
            <h1>Detalle del Producto</h1>
            <h2>{producto.nombre}</h2>
            <h3>{producto.id}</h3>
            <h4>${producto.precio}</h4>
        </section>
	)
}
```

De esta manera generamos url's dinamicas que renderizaran la informaciond de cada producto individualmente.

Cuando accedemos a la url "productos" se renderiza la lista con los "Links" de navegacion a cada producto.

![[Pasted image 20250110230815.png]]

Como dicho "Link", se genero dinamicamente con la url "productos" y el "id" podremos navegar hacia dicha url y se renderizara el detalle del produco.

![[Pasted image 20250110230956.png]]

Cunado hacemos "click" sobre cualquier "Link" se renderiza el detalle de cada producto.

![[Pasted image 20250110231050.png]]
## 9.6 Navegacion

En la seccion de url's dinamicas renderizamos el detalle del producto si quisieramos añadir un boton para regresar a la lista de productos tendriamos que usar el hook `useNavigate` de react-router para poder navegar entre el historial de url visitadas en nuestra aplicacion.

Se maneja de la misma manera que la propiedad  ``window.navigation.history`` de Javascript es decir podremos navegar entre el historial sumando o restandole una cantidad a dicha propiedad solo que react-router lo hace a traves de una funcion proporcionad por useNavigation.

Para añadir un boton que nos regrese a la lista de productos, debemos importar el hook "useNavigate" destructurarlo y pasar como parametro el valor para avanzar o retroceder, en este caso queremos regresar una posicion de donde se encuentra el historial actualmente por lo que pasaremos (-1).

```jsx
import {useParams, useNavigate} from 'react-router-dom'

function ProductDetail(){
	const {id} = useParams();
	const product = callSomeApi(id);
	//navigate
	const navigate = useNavigate();
	//handle
	const handleNavigate = () => navigate(-1);
	
	return(
		<section>
            <h1>Detalle del Producto</h1>
            <h2>{producto.nombre}</h2>
            <h3>{producto.id}</h3>
            <h4>${producto.precio}</h4>
            //boton para regresar a la lista de productos
            <button onClick={handleNavigate}>Regresar</button>
        </section>
	)
}
```

## 9.7 Rutas anidadas

Otra de las características de navegacion mediante la url es la de anidar rutas, es decir, definir una ruta con rutas propias o mas acordes a su contenido. 

Estas difieren de las url's dinamicas ya que un ruta anidada esta mas orientada a agrupar contenido relacionado dentro de una misma url y una url dinamica esta orientada a generacion de contenido a partir de solicitudes a API's externas.

Las rutas anidadas se definen en nuestro componente `BrowserRouter`, de hecho la declaracion sigue la misma logica que las rutas normales. Sin embargo hay un paso extra, hay que usar el componente `<Outlet />` en el componente padre (el componente asignado a la ruta principal) de nuestra ruta anidad, el componente ``Outlet`` se encargara de renderizar los componentes asignados a las rutas anidadas.

**Pasos**

1. Definir las rutas
2. Generar los links para acceder a dichas rutas.
3. Llamar al componente ``Outlet`` en el componente padre de nuestra ruta principal.

Paso 1: 

Definimos las rutas anidadas en nuestro componente ``BrowserRouter``.

Seguimos la misma sintaxis de las rutas normales, solo que anidamos componentes ``Route`` dentro de un componente ``Route``.

```jsx
<BrowserRouter>
  <Routes>
    //ruta normal
    <Route path="/home" element={<Home/>}></Route>
	//ruta anidada
	<Route path="/services" element={<Services/>}>
      <Route index element={<ServicesHome/>}></Route>
	  <Route path="guarantee" element={<Guarantee/>}></Route>
	  <Route path="/services/reviews" element={<Reviews/>}></Route>
	  <Route path="policy" element={<Policy/>}></Route>
	</Route>
  </Routes>
</BrowserRouter>
```

>**Nota**: Al anidar rutas NO es necesario escribir el nombre de la ruta padre en el path de la ruta anidada como lo podemos observar en la ruta anidada: "/services/reviews", lo cual podría quedar simplemente como: "reviews".

De igual manera que las rutas normales podemos anidar rutas y crear url's dinamicas.

En nuestro ejemplo creamos las rutas anidadas para la url "/services", dentro del componente Route con esta url anidamos mas componentes del mismo tipo de tal manera que para acceder al partado "policy" tendriamos que escribir la siguiente url:

>localhost:5173/services/policy

Pero para que se renderice el componente asignado a dicha ruta debemos hacer uso del componente ``Outlet`` que veremos mas adelante.

### Componente <Outlet />

Como mencionamos anteriormente el componente ``<Outlet>`` se encarfa de renderizar los componentes de las rutas anidadas y es necesario llamarlo en el componente que renderizara la ruta principal donde se anidaron las demas rutas.

En nuestro ejemplo, la ruta principal es "/services" y su componente a renderizar es ``<Services/>``, este componente se trata como el componente padre y en el debemos llamar al componente ``<Outlet>``

```jsx
//ruta anidada
<Route path="/services" element={<Services/>}>
```

Continuando con el ejemplo haremos el llamado de ``outlet`` en el componente ``Services``. Al ser un componente de la libreria react-router debemos hacer el import del mismo.

```jsx
import {Link, Outlet } from "react-router-dom";

export function(){
	return(
		<>
			<h1>Services</h1>
			<nav>
	            <Link to="/services">Inicio</Link>
	            <Link to="/services/gurantee">Garantia</Link>
	            <Link to="/servicios/policy">Politicas</Link>
	        </nav>
	        //llamado al componente outlet
	        <Outlet></Outlet>
		</>
	)
}
```

>Nota: Al hacer uso de Links para acceder a rutas anidadas es necesario especificar la ruta completa a diferencia del componte Route anidado que nos permitia omitir la ruta padre, de otra manera no se renderizara el componente asignado ya que accederemos a una ruta errronea.

## 9.8 Rutas por defecto 

Una ruta por defecto es aquella que se renderizara en caso de que accedamos a una ruta que no exista en nuestra aplicacion.

Esta se define dentro del ``BrowserRouter`` y se caracteriza porque a su path o ruta se le asigna un "\*", lo cual indica que cualquier ruta a la que se acceda y que no sea una de las existentes en nuestro proyecto renderizara el componente asignado a esta ruta. Muy util para definir un componente de "Error 404".

```jsx
<Route path="*" element={<Error404></Error404>}></Route>
```

# 9.9 Redirecciones


## Rutas Privadas


## 9.9 React Router 5

La principal diferencia entre esta version y la mas actual se encuetra en el componente 

```jsx
<Router>
	<Switch>
		<Route></Route>
	</Switch>
</Router>
```

----

# 10 Memorización

## Intro

## React Memo

## useCallback



# 11 Context API

## Introducción

A menudo en _react_ utilizamos las _props_ para compartir datos entre un componente padre y sus componentes hijos, si bien esta forma es adecuada, se convierte en una tarea complicada cuando tenemos que hacerlo a varios componentes hijos.

El _contexto_ permite que cierta información del componente padre esté disponible en cualquier componente del árbol que esté por debajo de él sin importar qué tan profundo sea y sin pasar la información explícitamente por medio de _props_.

Supongamos que necesitamos pasar algún valor del componente padre hasta el ultimo componente hijo del árbol de componentes, al hacerlo deberíamos irlo pasando a través de cada uno de los componentes hijo mediante las _props_ hasta llegar al ultimo.

![[Pasted image 20250118153434.png]]

Llevar acabo esta tarea requeriría de mucho tiempo, pues bien para solucionar esta problematica _React_ nos ofrece la _context API_, que nos permite compartir los datos entro todos los hijos de un componente padre la ventaja que nos ofrece esta API es que no importa lo profundo que este un hijo en el árbol de componentes los datos estarán disponibles para su uso.

> El contexto permite que el componente padre provea datos al árbol de componentes entero debajo de él.

Hay muchas utilidades para el contexto.

## Partes del contexto

Un contexto se compone de un _provider_ en el cual se almacenan las variables y funciones que se requieran proveer al arbol de componentes y un _consumer_ es un metodo por el cual podemos acceder a los elementos almacenados en el _provider_.

>Nota: En versiones de react menores a la 16 para acceder al _provider_ era necesario hacerlo mediante un metodo, en las versiones actuales se hace uso del "Hook" _useContext_.

## Creando un Contexto

Para entender como definir un contexto y consumirlo, implementaremos la funcionalidad de tema oscuro.

### Creando el contexto

Para crear un contexto debemos seguir los siguientes pasos.

1. Crear Contexto, exportarlo por defecto
2. Crear un Provider, es un Componente el cual contiene la logica de la aplicacion.
3. Consumir el contexto con el Hook: useContext.

**Recomendaciones**

- Crear un fichero `.jsx` por separado que contenga todo el codigo  del contexto.

#### createContext()

Es un hook que nos permite inicializar el contexto y que posteriormente nos servira para consumirlo mediante  el hook `useContext`.

Se puede definir en un archivo independiente o en el mismo en el que se declare el provider.

```jsx
//importamos createContext
import {createContext} from 'react';

//1. Creamos el contexto
// inicializamos una variable con el hook createContext
const ThemeContext = createContext();
```
#### provider

Es una función que retorna un componente de tipo ``<MyProvider.Provider></MyProvider.Provider>``. El provider se compone de : 

- children : Es la unica prop que recibe la funcion y sirve para indicar que el provider va a "proveer" a todos los componentes hijos del componente padre las variables que sean declaradas.
- variables : Son las variables, variables de estad, objetos, funciones que sean necesarios pasar a través del árbol de componentes del componente padre.
- data : Un objeto con las variables que se requieran pasara a los componentes hijos, esto para no pasar una por una de las variables.
- return : Un componente de tipo ``<Provider>`` al cual le debemos pasar la data y la prop children.

Ejemplo de provider.

```jsx
//ejemplo provider
const MyProvider = ({children}) => {
	//variables

	//data
	const data = {}
	//return componente de tipo provider
	return(
		<MyProvider.Provider value={data}>{children}</MyProvider.Provider>
	);
};
```

Continuando con el ejemplo para el Provider de tema oscuro.

```jsx
//importamos createContext
import {createContext} from 'react';

//1. Creamos el contexto
// inicializamos una variable con el hook createContext
const ThemeContext = createContext();

//2. Creamos al provider
//es una funcion que retorna un componente de tupo Context.Provider

const ThemeProvider = ({children}) => {
	//state para controlar el valor del tema
	const[theme, setTheme] = useState(initialTheme);
	//hanlder function para el cambio del tema
	const handleTheme = (e) => {
		if(e.target.value === "light")
			setTheme("light");
		else
			setTheme("dark");
	}

	//empaquetando las variables y funciones
	const data = {theme, handleTheme};

	//creando el componente provider
	return (
		<ThemeProvider.Provider value={data}>
			{children}
		</ThemeProvider.Provider>
	)
};

//exportamos el contexto
export default ThemeContext;

//exportamos el provider
export {ThemeProvider}

```


### Llamando al context

Una vez definido el contexto y especificament el provider, tenemos que usarlo como un componente de _react_ de tal manera que debemos envolver a todos los componentes a los cuales queramos pasarle las variables del contexto con el provider.

**Ejemplo** 

```jsx
//importamos nuestro Provider
import {ThemeProvider} from './ThemeProvider'
const MyPage = ()=> {

	return (
		<div>
			<ThemeProvider>
				<Header></Header>
				<Main></Main>
				<Footer></Footer>
			</ThemeProvider>
		</div>
	)
}
```

Al envolver todos nuestros componentes con el provider, ahora dichos componentes tendran acceso a las variables del provider.
### Consumiendo el contexto

**useContext**

La manera mas actual de consumir un contexto es mediante el hook _useContext_, esto lo hacemos en los componentes hijos.

**Ejemplo**

```jsx
//importamos useContext de react
import {useContext} from 'react'
//importamos nuestro contexto
import ThemeContext from './ThemeContext'

const Main = () => {
	//consumimos el contexto
	const [theme, handleTheme] = useContext(ThemeContext);
	
	return(
		<main className={theme}>
			<section>
				<h1>Utiliazando el contexto</h1>
				<label htmlFor="light">Light</label>
				<input 
	                type="radio" 
	                name="theme" 
	                id="light" 
	                value="light" 
	                onClick={handleTheme}
	            />
	            <label htmlFor="dark">Dark</label>
				<input 
	                type="radio" 
	                name="theme" 
	                id="dark" 
	                value="dark" 
	                onClick={handleTheme}
	            />
			</section>
			<section>
				<h2>Hello world</h2>
				<p>Lorem...</p>
			</section>
		</main>
	)
}
```

>Nota: El provider no puede llamarse en el mismo archivo en el que se llama al consumer (useContext()).


# 12 Reducer

## Intro

Un reducer (``useReducer``) una alternativa mucho mas eficiente al manejo de variables de estado (``useState``),hay que tomar en cuenta que no es un remplazo de ``useState``, mas bien es un complemento de _react_ para poder mantener nuestro codigo ordenado y refactorizado.

Su uso se basa en Funciones puras: realizan una misma tarea y para una misma tarea siempre van a devolver el mismo resultado.

>Nota: No podemos usar useEfects y tareas asincronas dentro de una funcion reductora, el principal objetivo de un _reducer_ es manejar explicitamente solo la variable de estado asignada.

## Partes de un Reducer

**Variable useState()**

Esta variable se crea con el Hook `useReducer()`, si nos fijamos en su declaracion podemos encontrar similitudes con las variables de estado declaradas por medio de ``useState()``. En efecto tiene similitudes dado que ambas nos permiten manejar variables de estado.

**Ejemplo de state con useReducer**

> const [state, dispatch] = useReducer(reducer, initialState, init);

Cuando declaramos un _state_ mediante el hook _useReducer_ debemos destructurarlo en dos variables: _state_ y _dispatch_. 

Estas variableas actuarian como el _state_ y _setState_ de _useState_.

Descripcion de todos los argumentos del hook _useReducer_.

- state : Un objeto con los valores a almacenar como estado, se sugiere almacenarlos en un objeto como se hacia en los componentes de clase.
- dispatch : Es la funcion que va actualizar el estado, esta ejecuta el reducer y recibe el action a ejecutar, dicho action es un objecto que se comone del _tipo_ de accion a ejecutar y un _payload_ datos con los cual va a trabajar el dispatch.
- reducer : Funcion reductora que se declara fuera del componente, recibe un objeto que representa el estado  (state) y un objeto que representa la accion a ejecutar (action) adicionalmente el _action_ puede recibir un _payload_ un valor para modificar el _state_. Siempre debe retornar el _state_.
- initialState : Es el estado inicial del state.
- init : Un metodo especial que se ejecuta solo una vez (en el montado del componente) y se encarga de inicializar el estado con un valor determinado.

**Reducer, intialState, init**

Como mencionamos anteriormente usamos el hook _useReducer_ para declarar una variable de tipo _state_, pero es necesario tambien declarar los parametros que le pasaremos a _useReducer_ para obtener nuestro _State_.


**Actions**

Las _actions_ son las acciones que el _reducer_ debe de realizar, se recomienda decláralas en un fichero independiente.

```jsx
export const TYPES = {
	INCREMENT : "INCREMENT",
	DECREMENT : "DECREMENT",
	INCREMENT_PER_5 : "INCREMENT_PER_5",
	DECREMENT_PER_5 : "DECREMENT_PER_5",
	RESET : "RESET"
}
```

Como vemos las _actions_ no son mas que un objeto con la descripcion de las tareas que se van a ejecutar en el _Reducer_, al declarar el _reducer_ se debemos evaluar las propiedades de nuestras _actions_ para que se ejecute la tarea correspondiente.

**Variable de estado useReduce()**


## Creando un reducer

**Actions***

Creamos nuestro objeto _TYPES_ que describe las acciones a ejecutar dentro de nuestro _reducer_.

"countActions.jsx"

```jsx
export const TYPES = {
	INCREMENT : "INCREMENT",
	DECREMENT : "DECREMENT",
	INCREMENT_PER_5 : "INCREMENT_PER_5",
	DECREMENT_PER_5 : "DECREMENT_PER_5",
	RESET : "RESET"
}
```

**Reducer**

El reducer se recomienda crearlo en un ficher independiente, este debe contener:

- initialState : Un objeto con las variables de estado con sus valores por defecto o iniciales, dependiendo de lo que se requiera.
- init : Es una funcion la cual se ejecuta una sola vez y tiene como funcion inicializar el `initialState` con un valor determinado o diferente a su estado por defecto, no es obligatorio, esto depende de las necesidades.
- reducer : Una funcion que se encarga de realizar las tareas que requieran modificar el _state_, esta recibe dos parametros: (state, action).

"countReducer.jsx"

```jsx
//importamos nuestros TYPES


//initialState
export const countInitialState = {
	count : 0
};

//funcion init
export const init = () => {
	return{count : countInitialState.count = 100;}
}

//reducer

export const countReducer = (state, action) => {
	//evaluamos el argumento recibido en el action.type
	switch(action.type){
		case TYPES.INCREMENT : 
			return {count : state.count + 1};
		case TYPES.DECREMENT : 
			return {count : state.count - 1};
		case TYPES.INCREMENT_PER_5 :
			return {count: state.count + action.payload};
		case TYPES.DECREMENT_PER_5 :
			return {count: state.count - action.payload};
		case TYPES.RESET :
			return countInitialState;
		default :
			return state;
	}
}
```

Como observamos en la declaracion del `countReducer`, es una funcion que recibe dos parametros:

- state : Estado actual.
- action: Es un objeto que debe tener dos propiedades : type y payload. _type_ debe contener la accion a ejecutar y _payload_ los datos para modificar el state.

Cada vez que llamamos a un reducer se evalua el _action.type_ para ejecutar la tarea adecuada, en este caso usamos la estructura condicional `switch/case` y en cada case definimos la accion a realizar, debemos tener en cuenta que esta funcion en general siempre debe devolver el estado.

Estas son las acciones basicas para crear nuestro reducer, ahora debemos utilzarlo dentro de un coponente de _React_.

"Counter.jsx"

```jsx
//importamos useReducer de react
import {useReducer} from 'React';
//de countAction.jsx 
//importamos nuestros types

//de countReducer.jsx debemos importar, si se requiere tambien init
//countInitialState, countReducer

const Counter = () => {
	//creamos una variable de estado de tipo useReduce
	const [state, dispatch] = useReducer(countReducer, countInitialState);

	//handler para los eventos
	//los handlers en lugar de llevar toda la logica
	//llaman al dispatcher y es este el que contiene la logica
	//y el que actualiza el estado
	//al llamar a la func disptach, solo le debemos enviar
	//un objeto con dos propiedades type y payload
	//type: es la accion a ejecutar
	//payload: datos que se requieran para modificar el state
	const handleIncrement = () => {
		dispatch({type : TYPES.INCREMENT})
	}

	const handleDecrement = () => {
		dispatch({type : TYPES.DECREMENT})
	}
	
	//creamos nuestro componente
	return(
		<div>
			<h1>Contador Reducer</h1>
			<button onClick={handleIncrment}>Increment</button>
			<button onClick={handleDecrement}>Decrement</button>
		</div>
	)
};

export default Counter;
```


# React Redux

## Intro

**Store**

Contiene el _state_, funciona como almacenamiento global por lo que se recomienda el uso de uno solo para toda la aplicacion, en el estaran almacenadas las variables de estado asi como sus funciones reductoras.

>Nota: Un store puede almacenar varias variables de estado y funciones reductoras, de hecho se recomienda almacenar todo este tipo de datos en el store de ahi que se vea al store como una funcion que centraliza la informacion de nuestra aplicacion.

**Dispatch**

Son las funciones que se encargaran de actualizar el _state_. 

**Action**

Representa a las funciones a ejecutar y que le son enviadas al dispatch para ejecutar una modificacion en el state. 

>Es un objeto con dos propiedades: action (representa la accion o funcion que el dispatch debe ejecutar para modifcar el state) y payload (datos para modifcar el state).

**Subscribe**

Es un manejador de eventos que va estar a la escucha de cambios en el state.

**Reducer**

Son funciones puras que van actualizar el _state_.

**Redux Diagram**

![[redux.jpg]]

**Redux Life Cycle**

![[redux.gif]]

## Configurando Entorno



# Redux Toolkit

**Configuracion**

1. Store
2. Slices
3. 
